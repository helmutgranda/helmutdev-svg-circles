<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Dynamic Cloud Stack</title>

    <script>
      class CircleStack extends HTMLElement {
        static get observedAttributes() {
          return ['count', 'color'];
        }

        constructor() {
          super();
          // Attach a shadow root to isolate styles and markup
          this.attachShadow({ mode: 'open' });

          // Initial structure in the Shadow DOM
          this.shadowRoot.innerHTML = `
            <div id="container"></div>
          `;
        }

        connectedCallback() {
          // Render when connected to the DOM
          this.render();
        }

        attributeChangedCallback(name, oldValue, newValue) {
          // Re-render if one of the observed attributes changes
          if (oldValue !== newValue) {
            this.render();
          }
        }

        render() {
          // Read attributes
          const count = parseInt(this.getAttribute('count') || '4', 10);
          const color = this.getAttribute('color') || '#0d0';

          // Calculate SVG width based on circle count
          const svgWidth = count * 40; 
          const svgHeight = 60; // A fixed height for this example
          const r = 20;         // Circle radius

          // Build circle elements
          let circles = '';
          for (let i = 0; i < count; i++) {
            // Adjust spacing as desired:
            // Here we use (30 + i*30) for x-coord
            const cx = 30 + i * 30;
            const cy = 30;          
            circles += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${color}"></circle>`;
          }

          // Update the container in the Shadow DOM with the SVG
          this.shadowRoot.querySelector('#container').innerHTML = `
            <svg width="${svgWidth}" height="${svgHeight}" style="border: 1px solid #ccc">
              ${circles}
            </svg>
          `;
        }
      }

      class CircleManager extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: 'open' });

          // Template: Circle stack + controls
          this.shadowRoot.innerHTML = `
            <div>
              <h2>Dynamic "Cloud" Stack</h2>
              <!-- Our circle-stack component -->
              <circle-stack id="circleStack" count="4" color="#0d0"></circle-stack>

              <div style="margin-top: 20px;">
                <button id="addButton">Add Circle</button>
                <button id="removeButton">Remove Circle</button>
              </div>

              <div style="margin-top: 20px;">
                <label for="colorInput">Circle Color (Text):</label>
                <input id="colorInput" type="text" value="#0d0" />
              </div>

              <div style="margin-top: 20px;">
                <label for="colorPicker">Circle Color (Picker):</label>
                <input id="colorPicker" type="color" value="#0d0" />
              </div>
            </div>
          `;
        }

        connectedCallback() {
          // Once attached, grab references to elements
          this.addButton    = this.shadowRoot.querySelector('#addButton');
          this.removeButton = this.shadowRoot.querySelector('#removeButton');
          this.colorInput   = this.shadowRoot.querySelector('#colorInput');
          this.colorPicker  = this.shadowRoot.querySelector('#colorPicker');
          this.circleStack  = this.shadowRoot.querySelector('#circleStack');

          // Set up event listeners
          this.addButton.addEventListener('click', () => this.addCircle());
          this.removeButton.addEventListener('click', () => this.removeCircle());

          // When user changes the text input
          this.colorInput.addEventListener('change', (e) => this.updateColor(e.target.value));

          // When user changes the color picker
          // 'input' event fires as soon as the user picks a color
          this.colorPicker.addEventListener('input', (e) => this.updateColor(e.target.value));
        }

        addCircle() {
          const currentCount = parseInt(this.circleStack.getAttribute('count'), 10);
          this.circleStack.setAttribute('count', currentCount + 1);
        }

        removeCircle() {
          const currentCount = parseInt(this.circleStack.getAttribute('count'), 10);
          // Ensure we don't go below 1 circle
          if (currentCount > 1) {
            this.circleStack.setAttribute('count', currentCount - 1);
          }
        }

        /**
         * Update the circles' color, and synchronize both the text input and color picker
         */
        updateColor(newColor) {
          // Update the circle-stack attribute
          this.circleStack.setAttribute('color', newColor);

          // Keep the text input in sync, if it differs
          if (this.colorInput.value !== newColor) {
            this.colorInput.value = newColor;
          }

          // Keep the color picker in sync, if it differs
          if (this.colorPicker.value !== newColor) {
            // If user typed something like "red", you could convert to a hex code.
            // For simplicity, let's just assign whatever we have:
            this.colorPicker.value = newColor;
          }
        }
      }

      // Register the custom elements
      customElements.define('circle-stack', CircleStack);
      customElements.define('circle-manager', CircleManager);
    </script>
  </head>

  <body>
    <!-- Render our circle manager, which includes the circle stack -->
    <circle-manager></circle-manager>
  </body>
</html>
